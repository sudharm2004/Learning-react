24/12/22
Day 1 >>>>>
Q.read about emmet  
Emmet is a plugin for text editors that allows users to write and expand abbreviations and snippets of HTML, XML, and other structured code. It is designed to be a fast and efficient way to write and edit code, by allowing users to quickly expand short, predefined code snippets into longer blocks of code.

Q.what is cdn
A content delivery network (CDN) is a system of distributed servers that deliver web content to users based on their geographic location. CDNs are used to improve the performance and availability of websites, by reducing the distance that data has to travel and providing redundant servers to handle traffic spikes.

CDNs work by storing copies of a website's static content, such as images, JavaScript files, and CSS files, on servers located in strategic locations around the world. When a user accesses a website that uses a CDN, the CDN will serve the content from the server that is closest to the user's location. This helps to reduce the amount of time it takes for the content to load, improving the user experience.

CDNs also help to improve the availability of websites by providing redundant servers to handle traffic spikes. If one server becomes overloaded or goes down, the CDN will redirect traffic to other servers in the network, helping to ensure that the website remains available to users.

Overall, CDNs are an important tool for improving the performance and availability of websites, and are used by many large and popular websites to deliver content to users around the world.

Q.what is crossorigin?

The same-origin policy blocks requests to other domains to prevent malicious websites from accessing sensitive information from a user's browsing session or making unauthorized requests on the user's behalf.

For example, imagine a user is logged into their bank account and visits a malicious website that attempts to make a request to the bank's API to retrieve the user's account balance or transfer funds. Without the same-origin policy, the malicious website could make the request to the bank's API and potentially access the user's sensitive information.

Another example is a cross-site scripting (XSS) attack, where an attacker injects malicious code into a website that the user visits. The malicious code could steal the user's session cookie and send it to the attacker's server, allowing the attacker to impersonate the user and perform actions on their behalf.

Q.Does react append content to root with some existing data or overwrites everything?
react overwrites everything that is already present in root

Q.i have created two roots in my react page and rendered both of them but only on root is being rendered why?
In a React application, it is generally not recommended to have multiple root elements in a single page. This is because React expects a single root element to wrap all of the other elements in the component hierarchy. If you try to render multiple root elements in a single page, only the first root element will be rendered, and the rest will be ignored.

Q.Async VS Defer
They are attributes of script tag.
when a page fetched from server there are two things first html rendering and script file loading.
Normal script tag:-
In this when page is loaded the html rendering start and when a script file is encountered the rendering is stopped and file is fetched and executed and once it is done the rendering starts again.
Script tag with async attribute:-
In this when page is loaded the html rendering starts and when a script file is encountered the the file is fetched asynchronusly while rendering is going on and once the file is fetched rendering stops and file is executed and after that rendering starts again.
Script tag with defer attribute:-
In this when page is loaded the html rendering starts and all script files encountered are fetched asynchronusly while rendering is going on and once the rendering is done all fetched files are executed one by one.
https://www.youtube.com/watch?v=IrHmpdORLu8

Emmet:

https://blog.logrocket.com/type-html-faster-react-emmet-vs-code/

https://dev.to/raaynaldo/speed-up-code-your-html-using-emmet-in-vscode-nesting-operators-201o

Library VS Framework:

https://www.freecodecamp.org/news/the-difference-between-a-framework-and-a-library-bd133054023f/

CDN:

https://www.imperva.com/learn/performance/what-is-cdn-how-it-works/

React VS React DOM:

https://www.geeksforgeeks.org/how-react-and-reactdom-works/

Cross-Origin:

https://www.dofactory.com/html/script/crossorigin

https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/crossorigin

Development VS Production build:

https://react-cn.github.io/react/downloads.html

Day 2 >>>>>

1.Bundlers:-
A bundler is a development tool that combines many JavaScript code files into a single one that is production-ready loadable in the browser. A fantastic feature of a bundler is that it generates a dependency graph as it traverses your first code files.
This implies that beginning with the entry point you specified, the module bundler keeps track of both your source files’ dependencies and third-party dependencies. This dependency graph guarantees that all source and associated code files are kept up to date and error-free.
VIDEO REFERENCE :- https://youtu.be/3UWlufSzO4k

2.Module:-
A module is a Javascript file.
However unlike a normal Javascript file, a module can specify which variables and functions can be accessed outside the module. Other sections of the module cannot be accessed. A module can also load other modules.

3.Packages:-In JavaScript, a package is a collection of code, resources, and metadata that is stored in a directory on your computer and is described in a package.json file

4.Dependencies:-They are all the packages that we need in the project

5.caret vs tilde:-
The three numbers in a version number represent the major version, minor version, and patch level. They represent the level of change in the software and the level of compatibility with previous versions.
The first number (the major version) represents a major release of the software that contains significant new features or changes. When the major version number changes, it means that the software has undergone significant changes that might break compatibility with previous versions.
The second number (the minor version) represents a minor release of the software that contains new features or changes that are backward-compatible with previous versions. When the minor version number changes, it means that the software has undergone changes that add new functionality but do not break compatibility with previous versions.
The third number (the patch level) represents a patch release of the software that contains bug fixes and other small changes. When the patch level number changes, it means that the software has undergone changes that fix bugs or improve performance but do not add new features or break compatibility with previous versions.
For example, if a software has version number of "1.2.3" it means that it is major version 1, minor version 2 and patch level 3 of the software.

The caret (^) is used in a package version number to indicate that the package should be updated to the latest version that is compatible with the current version. For example, if a package has a version number of "^1.2.3", it means that it should be updated to the latest version that is compatible with version 1.2.3. This would include any version that starts with "1.2", such as "1.2.4" or "1.2.5", but would exclude "2.0.0" or higher.

The tilde (~) is used in a package version number to indicate that the package should be updated to the latest version that is compatible with the current version, but only within the same minor version number. For example, if a package has a version number of "~1.2.3", it means that it should be updated to the latest version that is compatible with version 1.2.3, but only within the same minor version number. This would include any version that starts with "1.2", such as "1.2.4" or "1.2.5", but would exclude "1.3.0" or higher.

6.Package vs Package-lock-json:-package-lock-json locks and tells you exact version you are using in your system.
There is no need to put your package-lock-json file in gitignore.It maintains the integrity because it has hash which ensure that version on local and server are same(when you compare them).
Reference:-https://medium.com/hackernoon/do-i-really-need-package-lock-json-file-321ce29e7d2c#:~:text=If%20you're%20collaborating%20on,where%20npm%20modifies%20either%20package.

7.hash(sha512)
SHA-512, or Secure Hash Algorithm 512, is a hashing algorithm used to convert text of any length into a fixed-size string. Each output produces a SHA-512 length of 512 bits (64 bytes).
This algorithm is commonly used for email addresses hashing, password hashing, and digital record verification. SHA-512 is also used in blockchain technology, with the most notable example being the BitShares network.

8.Node module:-It contains all the modules of packages(reusable code)

9.npx:-It means execute using parcel.

10.type="module":-
A script tag having type="module" attribute specifies that it to be considered as a Javascript module. It may be importing other Javascript module(s) inside it and becomes a "top-level" module for the imported modules.
When a script file has the type="module" attribute, the browser treats it as a module and parses and executes the script in a specific way. The browser will create a new scope for the module, so that variables, functions, and classes defined within the module are private, and can only be accessed from within the module.

11.Hot module replacement:-
It refers that parcel keeps track of all updation.
It uses File Watchers algorithm(This algorithm is built in c++).
Whenever you update something in your code there is no need for you to manually to refresh the page parcel will automatically update it for you.Generally it updates Independent as well as Dependent modules in your project.
It update the changed modules and then track the module that are affected by the module changed and changes their value as well it does not update whole code every time.
for eg:-There are 4 module A,B,C,D and now B is changed then it will update the B and reflect it,it will not change A,C,D.
Now if C use data from B which changes then C will also be changed

12.dist:-
dist is a faster development build of our project which is hosted on server(local) by parcel.
It is minified version of our huge project like we used npm build in webpack(harry tutorials).

13.Parcel advantages:-

1. bundling our code
   2)minifying the code
   3)removing all the console log(cleaning the code)
   4)it does image optimization(compress them)
   5)it provides caching while development->The time required to build development build first is largest and subsequently the time required decreases
   6)It compresses your files(decreases the size of your js,html,css files). for eg:-it changes names of your variables (with large names )in js to some small names like alphabets/something.
   7)It also handles compatability with older versions.
   8)It enables https on development build.
   9)It manages your port number.
   10)It uses consistent hashing algorithm.
   11)It has zero configuration.

   14.We should put parcel.cache in gitignore because anything that can be auto generated will be put in gitignore.

   15.Transitive dependencies:-
   A transitive dependency is a library or module that is depended on by another library or module, even though the main application code does not directly depend on it.
   For example, suppose that a React application depends on library A, which in turn depends on library B. In this case, library B is a transitive dependency of the React application, because the application code does not directly depend on it, but it is required for library A to work correctly.

   16.BrowserList:-It is a package used to make your web app compatible for older versions of browser.
   It is automatically added by parcel when we are using it.
   Browserslist is a tool that allows specifying which browsers should be supported in your frontend app by specifying "queries" in a config file. It's used by frameworks/libraries such as React, Angular and Vue, but it's not limited to them.
   Reference:-https://browsersl.ist/

   17.package.json scripts:-
   scripts are terminal commands that perform a set of actions.
   To execute your Script, use the ‘npm run <NAME-OF-YOUR-SCRIPT>’

What we done today:-
We installed parcel (a bundler) as a dev dependency in our project first.
We installed react package in our project......we are not using cdn any more.
We installed react-dom package in our project......we are not using cdn any more.

Day 3 >>>>>>
1)Babel-plugin-transform-remove-console:- It is used to remove the console logs from your projects.

2)What are plugins

3)what is .babelrc?
It is a configuration file for babel

4)React Key Concilation:-Key should be given to children elements of similar types.
When elements are rendered in a list, React uses the key attribute to keep track of which elements are added, removed, or re-ordered. Without a key, React doesn't have a way to keep track of the elements in the list, so it has to re-render the entire list whenever a change is made.

When React renders a list of elements, it creates a virtual representation of the elements in memory, called the virtual DOM. The virtual DOM is a lightweight representation of the real DOM, and it is used to keep track of the elements that are rendered in the list.

When a change is made to the list, such as an element being added, removed, or re-ordered, React has to update the real DOM to match the virtual DOM. In order to do this, React uses a process called "reconciliation". During reconciliation, React compares the virtual DOM with the real DOM, and it determines which elements have changed and need to be updated.

5)Virtual Dom and Real dom in react
In React, the virtual DOM (VDOM) is a lightweight representation of the real DOM (Document Object Model). The real DOM is the actual structure of the web page, and it is used by the browser to display the content of the page. The virtual DOM, on the other hand, is a representation of the real DOM that is kept in memory, and it is used by React to efficiently update the real DOM.

The virtual DOM is a tree-like structure, where each node represents an element in the real DOM. When a change is made to the virtual DOM, such as an element being added or removed, React uses a process called "reconciliation" to determine how the real DOM should be updated.
The use of virtual DOM allows React to minimize the number of changes made to the real DOM, thus making the updates faster and more efficient. This is important because updating the real DOM can be slow and resource-intensive, especially when working with large or complex web pages.

It's worth noting that React's virtual DOM does not physically exist on the page, it only exists in memory and is used to optimize the update process. It's a mechanism that React uses to optimize the update process, making it faster and more efficient

6)JSX
JSX is not html in javascript..it is a html like syntax in javascript
Superpowers of jsx:-
readability,maintainability and protects from cross side scripting
JSX itself does not directly prevent cross-site scripting (XSS) attacks. However, when used in conjunction with other security measures, it can help to make it more difficult for an attacker to exploit XSS vulnerabilities in a web application.

When you use JSX to build a React application, React automatically escapes any user input that is included in JSX elements. This means that any special characters that could be used to inject malicious code (such as <, >, and &) are converted to their corresponding HTML entities, so that they are not treated as code.
For example, if an attacker tries to include a script in a user's input like this:

<script>alert("XSS Attack!")</script>

React will automatically escape the special characters, so that it is rendered as plain text on the page, not as a script that can be executed by the browser:

&lt;script&gt;alert("XSS Attack!")&lt;/script&gt;

7)What is difference between html and jsx

8)what is babel and how it is used for transpiling jsx or es6 code?
Whenever you run build or start command in parcel first of all babel is used to transpile(convert jsx to normal javascript,convert to compatible with previous versions of browsers) the whole javascript code
Babel takes jsx and internally uses react.createElement to convert into object(object created by react.createElement) and then transform it into dom
BABEL=>JSX=>react.createElement=>OBJECT=>DOM

REACT CODE:-
const Header=()=>{
return (

<h1>hello world! through functional component</h1>
)
}
const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<Header/>);

CODE TRANSPILED BY BABEL:-
const Header = () => {
return React.createElement("h1", null, "hello world! through functional component");
};

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(React.createElement(Header, null));

When you use Parcel to build a React application, it automatically includes and configures Babel to transpile JSX code into JavaScript that can be understood by web browsers.

Parcel is a web application bundler that can handle many types of files, including JavaScript, CSS, and HTML. One of its features is the ability to automatically detect and handle the dependencies of your application, including transpiling JSX code with Babel.

When you start a development server with parcel, it will look for any .js, .jsx files in your application and it will automatically transpile them using Babel. It will also look for any configuration files like .babelrc or package.json, if it finds any of these configuration files it will use them.

So you don't have to explicitly include Babel as a dependency in your project or configure it to transpile JSX code. Parcel will handle it automatically for you.

When you build your application with parcel, it will look for any JSX elements in your code, it will transpile them using Babel to JavaScript, and bundle them with the rest of your application. So the final output will be a single JavaScript file that contains all the code in your application, including the transpiled JSX code, that can be understood by web browsers.

In summary, when you use Parcel to build a React application, it automatically includes and configures Babel to transpile JSX code into JavaScript that can be understood by web browsers. You don't have to explicitly include Babel as a dependency or configure it, Parcel will handle it automatically for you. It will look for any JSX elements in your code, transpile them using Babel and bundle them with

9)Component=>
Component is a JavaScript class or function that represents a reusable piece of UI.
Functional components: These are JavaScript functions that accept props as an argument and return a JSX element. They don't have their own state and lifecycle methods.
Class components: These are JavaScript classes that extend the React.Component class. They have their own state and lifecycle methods. They also accept props as an argument and return a JSX element, but the way that it is done is different from functional components.
Functional component
Functional component is normal function that returns a jsx.
Name of a component starts with a capital letter.

10)Component Composition
Component composition is a technique in React where you can build a complex component by combining smaller, simpler components. The smaller components are called "composable components" or "sub-components" and the complex component is called the "composite component."
For eg:-
function WelcomeDialog() {
return (

<div>
<h1>Welcome</h1>
<p>Thank you for visiting our site.</p>
<Button label="Close" onClick={() => console.log("closing dialog")} />
</div>
);
}

function Button({ label, onClick }) {
return <button onClick={onClick}>{label}</button>;
}

In this example, the WelcomeDialog component is the composite component, and the Button component is the sub-component. The WelcomeDialog component renders the Button component inside its JSX.

11)Type Attribue
The type attribute is used to specify the type of script is being used

12)Multiple root.render
In your react app you can have multiple roots and multiple root.render(react.renders) but you should have only one 

Day 4 >>>>>>
1)Any jsx expression include only one root parent within which all children elements are included and further child elements can be included in those children elements.

2)React.Fragment
Any jsx expression must have single root parent.So you create a div with no classess/id and then add include all children elements into it.But this forces you to add unnecessary extra div in your code.
for eg:-
const header=()=>{

  <div>
    <Logo/>
    <NavItems/>
  </div>
}
Now React.Fragment is component that is exported by React and you can use it instead of a extra div as shown below.
const header=()=>{
  <React.Fragment>
    <Logo/>
    <NavItems/>
  </React.Fragment>
}
This short hand syntax for <React.Fragment></React.Fragment> is <></>

3)Can we use React.Fragment in React.Fragment?
Yes of course!

4)join array items?
You can join array items in JavaScript using the join method. This method concatenates all elements of an array into a single string, separated by a specified separator.
for eg:-
let arr = [1, 2, 3, 4];
let str = arr.join(', ');
console.log(str); // Output: "1, 2, 3, 4"

5)Config driven ui?
In this UI changes according to the data provided which it means it is driven by configuration provided by backend.
for eg:- swiggy don't have add carousels for customer in maharashtra then it will get data from backend which provides config about not to show carousel ads while other location it may show the carousel ads.

6)optional chaining?
The optional chaining (?.) operator accesses an object's property or calls a function. If the object accessed or function called is undefined or null, it returns undefined instead of throwing an error.
The ?. operator is like the . chaining operator, except that instead of causing an error if a reference is nullish (null or undefined), the expression short-circuits with a return value of undefined. When used with function calls, it returns undefined if the given function does not exist.

For eg:-
const nestedProp = obj.first?.second;

By using the ?. operator instead of just ., JavaScript knows to implicitly check to be sure obj.first is not null or undefined before attempting to access obj.first.second. If obj.first is null or undefined, the expression automatically short-circuits, returning undefined.

7)What is cloudinary id?

8)Spread operator?

9)diffing algorithm,react fiber?
diffing algorithm is an algorithm used by react in order to differ the old virtual dom and new virtual dom and find the changes/updates that are made and to be reflected in the real dom.
It is based no two assumptions:-
1)If the root elements are different then it will create completely different tree hence previous dom is unmounted completely and new virtual dom is rendered.
2)If root elements are same then it compares attributes then it compares childrens recursively.If a parent element has multiple same elements in it then key is used to compare them.

10)why not to use index as a key in react?
In React, keys help identify which items have changed, are added, or are removed. Using the index of an item as a key value is discouraged because it can lead to unexpected behavior when items are reordered or added/removed.
Imagine you have a list of items that you are rendering using map function, with each item being assigned a unique key. If the items in the list change frequently (e.g. being added, removed, or reordered), the index of each item will also change. When this happens, React will re-render the entire list and treat the new list as a completely different set of elements from the previous list, even if some of the items are the same. This can cause performance problems because React will need to re-render the entire list each time there is a change, instead of just updating the specific elements that have changed.

Day 5 >>>>>>
1)What are imports and exports
Imports and exports are JavaScript language features that allow you to include code from one module in another module. The "import" statement is used to include exports from another module in your code, while the "export" statement is used to make values or functions available for other modules to use. Imports and exports allow you to modularize your code and share functionality between different parts of your application.

here are two ways to export values from a module: named exports and default exports. Here's a brief explanation of each and how to import them:

Named exports:

Named exports allow you to export multiple values from a module using named identifiers.
To export a value as a named export, you use the export keyword followed by the identifier or expression you want to export.
Example: export const myFunction = () => { ... };
To import a named export, you use the import keyword followed by the name of the exported identifier in curly braces {}.
Example: import { myFunction } from './myModule';
Default export:

Default export allows you to export a single value from a module as the default export.
To export a value as the default export, you use the export default keyword followed by the identifier or expression you want to export.
Example: export default myFunction;
To import the default export, you use the import keyword followed by any identifier of your choice.
Example: import myFunction from './myModule';
Here's a summary of the import syntax for named and default exports:

Named exports:
// Exporting
export const myFunction = () => { ... };
// Importing
import { myFunction } from './myModule';

Default export:
// Exporting
export default myFunction;
// Importing
import myFunction from './myModule';

2)Input tag not working??
A component in React is updated when its state or props change. React will re-render the component whenever a change is detected, which ensures that the component's output is updated with the latest data.
When you create a input tag in react and try to enter input in it you are not able to do it because
If you have not defined a onChange event handler for an input in React, it may not work because the input's value will not change when the user types in it. This is because React's state management system relies on the onChange event to detect changes in the value of an input element and update the state accordingly. Without the onChange event handler, the input's value will remain unchanged, and the user will not be able to enter any text. To fix this issue, you should add an onChange event handler to the input element and use it to update the state with the new value.

3)What is state?
In React, state refers to the data or variables that determine a component's behavior and render information to the user. It is considered as an internal data structure of a React component and is only accessible within the component.

4)what is react hooks?
React hooks are nothing but just a bunch of javascript functions.
In React, hooks are a way to add state and other React features to functional components. They allow developers to use state and other React features without writing a class component.
Hooks starts with use keyword.

5)Usestate Hook
Usestate hook is used to create local state variables in react.
Usestate returns an array which includes two value first one is variable that stores value and second one is the function used to set(change) the value of function.
Syntax:-
const [state, setState] = useState(initialState);
state is name of variable in which value is stored.
setState is a function which is used to update the state.The setState function in React updates the component's state and triggers a re-render of the component. When the component's state is updated, React performs a shallow comparison between the current state and the next state to determine if a re-render is necessary. If the comparison determines that the component's render method should be re-executed, the component is re-rendered, and the updated state is reflected in the component's UI.

Day 6 >>>>>>
1)What are microservices?
Microservices is an architectural style that structures an application as a collection of small, independent services that communicate with each other through APIs. Each microservice is focused on a specific business capability and can be developed, deployed, and scaled independently of the other services in the application. This approach enables faster development, easier maintenance, and greater scalability compared to a monolithic architecture where everything is tightly coupled and deployed as a single unit.

for eg:-
There is different team and project for UI,BackEnd,Logs,Notification,etc.

2)What is useeffect?
useEffect is a Hook in React that lets you synchronize a component with an external system. It can be used to fetch data from an API, handle user events, update the document title, and many other things.

The useEffect function takes two arguments:

A)A callback function that performs the side effect.
B)An optional dependencies array, which lets you control when the effect should fire.

Useeffect callback function is called after the render.

We useeffect(componentDidMount in class based component) for api call because first we render with shimmer or dummy ui until we fetch data and once we fetch data then we update state and render the real data.

3)What is shimmering effect?
Shimmer effects are loading indicators used when fetching data from a data source that can either be local or remote. It paints a view that may be similar to the actual data to be rendered on the screen when the data is available.

4)What is conditional rendering?
Conditional rendering in React refers to the practice of rendering different components or elements in the UI based on certain conditions. For example, you may want to display a specific component to a user based on whether they are logged in or not.

5)In react javascript expressions can executed in curly braces but javascript statements cannot be executed why?
In JavaScript, expressions are pieces of code that return a value. They can be as simple as a single value like 5, or as complex as a function call, like Math.max(5, 10).

On the other hand, statements are complete units of execution. They don't return a value, but instead carry out some action, such as declaring a variable let x = 5, or defining a loop for (let i = 0; i < 10; i++).

In React, the curly braces are used to embed expressions, which return a value, in JSX code. On the other hand, JavaScript statements do not return a value, they execute actions. So, including a JavaScript statement inside the curly braces would not make sense, as it would not have any value to be embedded in the JSX. That's why JavaScript statements cannot be executed within curly braces in React.

6)What is monolith architecture?
Monolithic architecture is a software design pattern where the entire application is built as a single, independent unit. In a monolithic architecture, all the components of the system, such as the user interface, business logic, and database access, are tightly integrated into a single process or application. The entire application runs on a single server and communicates through a single database. Changes to the system often require a complete rebuild and redeployment of the entire application.
For example, consider a website for an e-commerce business that includes a shopping cart, payment gateway, product catalog, and order management system. In a monolithic architecture, all these components would be tightly integrated and deployed as a single, monolithic application.

7)What is async and await?
Async and Await are two keywords in JavaScript that are used to handle asynchronous operations in a more synchronous manner. The async keyword is used to declare an asynchronous function. The await keyword is used inside an asynchronous function to wait for the resolution of a Promise and to get the resolved value. With await, the code inside the function is blocked until the awaited Promise is resolved, making it look like a synchronous operation. This helps to simplify the handling of asynchronous operations and eliminates the need for callback functions and chaining Promises.

Day 7 >>>>>>

You can create multiple routes in a react app all you do is use createBrowserRouter to create routes and provides them as routes to the <RouterProvider router={router}/>

1)Never create a component inside an component

2)Never create Local state variable(state/usestate) in if-else condition or loops because this will create a incosistency that causes confusion for react.You should not create state variables in if-else statements or in loops in React because they may not be updated properly or may cause unexpected behavior. When a state variable is updated inside an if-else statement or a loop, it may not trigger a re-render of the component and cause unexpected behavior. Additionally, state variables should only be updated using the setState method to ensure that the component is re-rendered whenever the state changes. When you create a state variable inside an if-else statement or a loop, it becomes a local variable, which is not associated with the state of the component and will not trigger a re-render when it changes.

3)createBrowserRouter is the function that an array of objects as argument in which each object includes path and component related to it.Basically it is used to create router.
for eg:-
const appRouter=createBrowserRouter([
{
path:'/',
element:<Applayout/>
},
{
path:'/about',
element:<About/>
}
])

4)RouterProvider
In order to provide router to your router we use RouterProvider in render in which we pass a prop router={appRouter}
for eg:-
root.render(<RouterProvider router={appRouter}>)

5)errorElement
It is used to show the component that you want to display if invalid url/path is entered.
for eg:-
const appRouter=createBrowserRouter([
{
path:'/',
element:<Applayout/>
errorElement:<Error/>
},
{
path:'/about',
element:<About/>
}
])

6)useRouteError
It is hook that returns a object that includes the information about error related to route.

7)Single Page Application
An SPA (Single-page application) is a web app implementation that loads only a single web document, and then updates the body content of that single document via JavaScript APIs such as XMLHttpRequest and Fetch when different content is to be shown.
A single-page application (SPA) is a web application or website that interacts with the user by dynamically rewriting the current page rather than loading entire new pages from a server. In an SPA, a single HTML page is dynamically updated as the user interacts with the application, giving the feeling of a smooth and fast user experience.

8)Two types of routing
Server-side routing refers to the process of handling requests for specific URLs on the server and returning the appropriate content in response. This is the traditional approach to handling routing, where the web server receives a request for a specific URL, looks up the appropriate page or resource, and returns the HTML content to the client. This approach can be useful for websites that have a lot of dynamic content or require a lot of server-side processing.

Client-side routing, on the other hand, refers to the process of handling routing on the client-side using JavaScript. In this approach, the web server returns a single HTML page that contains all the necessary JavaScript and CSS files. When the user clicks a link or enters a URL, the JavaScript code on the page intercepts the request and dynamically updates the content of the page without reloading the entire page. This approach is often used in Single Page Applications (SPAs) and can result in faster page loads and better user experience.

9)Link component
Link component is used to link to routes.It does not reload the whole pages.

10)Nested Routing
If you want to load/show <About/> component when going to '/about' route but you want your header and footer there so you want replace <Body/> with <About/> for '/about' route this is called Nested Routing.

Outlet:-
<Outlet/> is a component which includes all the childrens according to route.

foreg:-
const Applayout=()=>{
return (
<>

 <Header/>
<Outlet/>
<Footer/>
</>
);
}

const appRouter=createBrowserRouter([
{
path:'/',
element:<Applayout/>,
errorElement:<Error/>,
children:[
{
path:'/',
element:<Body/>
},
{
path:'/about',
element:<About/>
}
]
}

])

11)useParams
It is a hook provided by react-router-dom which gives parameters in the current url/path.

12)Object.values
In JavaScript, Object.values is a method that returns an array of the values of all enumerable properties of an object. It takes an object as an argument and returns an array of its values. For example:
For eg:-
let obj = { a: 1, b: 2, c: 3 };
let values = Object.values(obj);
console.log(values); // [1, 2, 3]

13)What happens when you console.log(useState())?
It logs a function in the console which shows that useState() is nothing but a javascript function at the end.

14)Nested Routing More deeply
Suppose you want to show profile in about on path /about/profile you can do as following
const Applayout=()=>{
return (
<>

 <Header/>
<Outlet/>
<Footer/>
</>
);
}

const appRouter=createBrowserRouter([
{
path:'/',
element:<Applayout/>,
errorElement:<Error/>,
children:[
{
path:'/',
element:<Body/>
},
{
path:'/about',
element:<About/>,
children:[
{
//do not do '/profile' cause server will assume path localhost:1234/profile and only profile means you want to
//append it to existing path/route i,e, to localhost:1234/about/profile
path:'profile'
element:<Profile/>
}
]
},
{
path:'/restaurant/:id',
element:<RestaurantDetails/>
}
]
}

])

Day 8 >>>>>>
1)We cannot create class based component without extending a class by React.Component and using render method

2)render method is a method in the class based component that return some JSX.When a class-based component is called in the code, an instance of the component is created and rendered. The component's render method is then used to generate the JSX that represents the component's UI.

3)Constructor
It is a method in class based component/class that is called first.
every class based component has constructor which takes props as argument and state are declared and intialised in the constructor.
constructor(props)
{
super(props)
this.state={
state1=value,
state2=value
};
}

4)Props in class based components
To access props in class-based components, you can use the "this.props" object. Props are passed to the component as arguments to the constructor and can be accessed using the "this" keyword inside the component.

5)state and updating states in class based components
To use state in class-based components, you need to initialize the state in the constructor of the component.To update the state, you can use the setState method, which takes an object that represents the updated state. You should never modify the state directly using assignment (e.g. this.state.count = 1).
for eg:-
class MyComponent extends React.Component {
constructor(props) {
super(props);
this.state = {
count: 0,
};
this.incrementCount = this.incrementCount.bind(this);
}
incrementCount() {
this.setState({
count: this.state.count + 1,
});
}
render() {
return (

<div>
<p>Count: {this.state.count}</p>
<button onClick={this.incrementCount}>Increment</button>
</div>
);
}
}

6)Lifecycle in React
In REACT class based components constructor is called first(in beginning) then render method is called

7)componentDidMount
componentDidMount is a lifecycle method in React class-based components. It is called after a component is initially rendered to the DOM.

8)React lifecycle
React Lifecycle is divided into two phases
I)Render Phase:-
In this phase constructor and render method is called
II)Commit Phase:-
In this phase React first actually update the real DOM and then run componentDidMount() method.

So now if there are more than one children let's say there are two childrens then first constructor and render of parent will be called later on constructor and render of first child is called and then constructor and render of second child is called and then componentDidMount of first child and then second child and then of parent is called.
now this happens because react patches up render phase of multiple childrens and then later on start commit phase for each children .....Now React does this because if it allows for first children to execute componentDidMount and there is api call in it that changes state then it will again goes to rendering phase and committing phase because of which other childrens are delayed/takes more time hence for optimization react does this.

For More Understanding:-https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/

9)Research Question:-
I)Why can i make componentDidMount async but i cannot make callback function in useeffect async
componentDidMount is a lifecycle method of class components. It's called after the component has mounted and the initial render is complete. This means that the component's DOM nodes have been created and added to the page, and the component's initial state and props have been set. componentDidMount is a good place to perform side effects like making an API call or setting up an event listener.

useEffect, on the other hand, is a hook that allows you to synchronize a component with an external system. For example, you can use useEffect to start a timer or to make an API call and update the component's state based on the response. Unlike componentDidMount, useEffect runs after every render, which includes the initial render. This means that if you want to run a side effect only once, you need to specify this by providing an empty array as the second argument to useEffect.

The reason that useEffect and its cleanup function must return a synchronous function or null, while componentDidMount can return a promise or any value, is because of how React manages and coordinates the effects. When using useEffect, you need to specify when the effect should re-run by providing its dependencies in the second argument. React will re-run the effect whenever any of the dependencies change.

The return value of useEffect is used to clean up any ongoing work before the effect is re-run. For example, you might use the cleanup function to stop a timer or to remove an event listener. Since the cleanup function is used to synchronize with the external system, it must be a synchronous function or null to ensure that React has full control over when and how it is executed.

If you use async in the useEffect or its cleanup function, it could cause unpredictable behavior, as React will not have full control over the timing and sequence of the cleanup and effect functions. In such cases, the cleanup function might not be executed in a timely manner or might not be executed at all, leading to unexpected behavior or memory leaks.

Suppose you have async of useffect callback function which is used to fetch data from api and it returns cleanup function to abort the api call if user navigates to another component and unmounts the current component as expected when a user navigates to another component while still fetching is going on api call should be aborted but since the callback function is async cleanup function will not be called instantly when component unmounts thus leading unexpected behaviour.

In conclusion, componentDidMount and useEffect are two different tools for performing side effects in React. componentDidMount is a one-time setup method for class components, while useEffect is a hook that allows you to synchronize a component with an external system and run an effect after every render. It's important to understand the difference between these two tools and how to use them properly to ensure that your components behave as expected.

II)Why do we have to write counstructor and super(props) in class based component
The constructor and super(props) are used in class-based components to set up the initial state and to call the constructor of the parent class.

The constructor is a special method that is called when an object is created from a class. In React, the constructor is used to set up the initial state of the component, to bind event handlers to the instance of the component, or to perform any other setup that is required when a component is first created.

super(props) is used to call the constructor of the parent class. In React, the parent class is React.Component. By calling super(props), you are giving the parent class the opportunity to set up its own state or perform any other initialization that is required before the component is fully created.

It's important to note that the constructor and super(props) are not necessary in every class-based component. In many cases, you can use state initializations and component lifecycle methods without using the constructor and super(props). However, if you need to do more complex setup when the component is created, then the constructor and super(props) are important to include

10)What happens if we are making an api call in componentDidMount of a child component?
In this case first parent's constructor and render method is runned then child's constructor and render method is runned now componentDidMount has an api call and we declared it as async(async componentDidMount) so it will take some time to load and hence parent's componentDidMount method is runned and then componentDidMount of child is runned.

11)Never ever compare react lifecycle with functional components.

12)i have setinterval function with time of 1 second in useeffect with dependency array having no state or props in it in my about componenent but when i navigate to another component and comeback to about component my time for setinterval subsequently increase why?

When you navigate away from a component, React unmounts the component and its state is lost. When you navigate back to the component, a new instance of the component is created and the component is re-mounted.

In this case, since you have a setInterval function running in a useEffect hook, each time you navigate to the component, a new interval is created and starts counting from 1 second. When you navigate away from the component, the previous interval continues running and doesn't stop, even though the component is no longer visible.

When you navigate back to the component, a new interval is created and starts counting from 1 second, so the time displayed in the component will be the sum of the time elapsed in all the previous intervals plus the time elapsed in the current interval.

To fix this issue, you can add a cleanup function to the useEffect hook that stops the previous interval when the component is unmounted. You can do this by returning a function from the useEffect hook that calls clearInterval with the ID of the interval.

13)When will clean up function of useEffect will be called if i have state/props in its dependency array?
Yes, you can add a cleanup function to an useEffect hook that has dependencies. In this case, the cleanup function will be called every time before the effect runs, including the first time when the component is mounted. This can be useful if you need to perform some cleanup actions before the effect re-runs.

Day 9 >>>>>>
1)Custom Hooks
In React, a custom hook is a reusable function that encapsulates some specific logic and can be shared across multiple components. Custom hooks allow you to abstract away complex logic and state management from your components, making them more focused and easier to reason about.

2)Chunking,Code splitting,Dynamic bundling,Lazy loading,onDemand loading
let's say u have large web application for shopping like makeMyTrip so there will be various sections on your web page and various sections will have multiple components So when u bundle them all the file of bundled js file will very large and hence it will make our app slow hence we use Chunking/Lazy loading/onDemand loading.
Now this is how it works,now suppouse website makeMyTrip has three sections homepage,flights,trains,packages,etc.
Now user may come only to visit flights and book them and may not even goes trains section...Now if we bundle all of them together we are bundling and loading the code that is not even needed.......hence what we do is lazyload/dynamically import it which means our intial bundled index.js file does not include code for flights,trains,packages,etc. it only includes bundled code for homepage and when user goes to other sections the code for other sections is dynamically bundled and loaded into the browser.

Now in our food app we are lazy loading our instamart so in our network tab you can check that when u go to instamart section the new instamart.js file is loaded.

Syntax:-
//Above function component
const Instamart=lazy(()=>import("./components/Instamart"))
//In createBrowserRouter configuration
{
path:'/instamart',
element:<Instamart/>
}

But⚠️ this code will display an error 😒 because since we are loading the instamart component after we click on the link now it takes time to load the component let's say 30ms but react tries to render instamart before it was loaded and hence it shows error (in the food app we are using useRouteError it will show error component).
But🧐 if you navigate to another component and comeback to this component it will show you the Instamart component 🤯
Now what happens when you load the component through lazy() React suspends the rendering and renders the component when it is loaded so when you navigate first it shows error.

Now to resolve this we need to use <Suspense/> component exported by react to tell react it is loaded through dynamically and hence react internally will handle the error and show u the component.
<Suspense/> component take a prop called fallback which is takes component and show this component until your component is loaded(Instamart in this case).We can use it for shimmer effect
//Above function component
const Instamart=lazy(()=>import("./components/Instamart"))
//In createBrowserRouter configuration
{
path:'/instamart',
element:<Suspense fallback={<Shimmer/>}><Instamart/></Suspense>
}

3)<Suspense/>
Suspense is a feature in React that allows for the declarative fetching of data as a component is being rendered. This feature enables developers to show a loading spinner or placeholder content while the data is being fetched, improving the user experience. With Suspense, data fetching can be integrated directly into the component tree, reducing the need for complex data fetching logic and making it easier to manage and reason about the data in your app.

4)Chunking,Code splitting,Dynamic bundling,Lazy loading,onDemand loading
Chunking: It is a technique to split the large code into smaller chunks to make the initial loading faster and more manageable. This can be especially helpful when dealing with large codebases or slow internet connections.

Code splitting: It refers to splitting a large codebase into smaller, more manageable parts, or “chunks”. This allows the browser to only load the necessary code for a specific page or component, improving the performance and loading time of the website.

Dynamic bundling: This refers to the process of generating and serving JavaScript bundles on the fly in response to specific user requests. This can be used to improve performance by only loading the code that the user needs at a given time.

Lazy loading: This refers to the process of deferring the loading of resources until they are actually needed. This can be useful for optimizing performance, as the browser will only load the necessary resources, rather than all resources at once.

On-demand loading: This is a technique where resources are only loaded when they are needed, rather than all at once. This can help improve the performance of a website or application, as it reduces the amount of data that needs to be loaded and processed at once.

5)Advantages of Code Splitting:

Reduced initial load time: By splitting the code into smaller chunks, only the necessary code is loaded initially, reducing the size of the initial payload and improving the initial loading time.

Improved User Experience: By loading only the required code, the user is able to interact with the application faster, leading to a better overall user experience.

Better Resource Management: By loading only the required code, the browser has to process less JavaScript, freeing up memory and improving the overall performance of the application.

Optimization of SEO: By loading only the required code, the initial HTML content can be rendered faster, which is crucial for SEO optimization.

Disadvantages of Code Splitting:

Increased complexity: Code splitting requires a deeper understanding of the application structure and more effort in terms of implementation. This can lead to increased complexity and development time.

Performance Overhead: The process of loading different chunks of code can cause additional overhead and negatively affect the overall performance of the application.

Increased Maintenance Effort: Managing multiple code chunks can increase the maintenance effort and lead to additional debugging and testing.

Browser Compatibility: Some older browsers may not support the dynamic import() function used for code splitting, leading to compatibility issues.

6)Execution flow of custom hook
When the custom hook updates its internal state using the useState hook, it triggers a render update in the React DOM. This render update causes the component that uses the custom hook to be re-rendered with the updated state.

The execution flow of a custom hook and a component using it is as follows:

The custom hook is executed when the component that uses it is mounted. The custom hook can use other React hooks like useState or useEffect to manage its internal state.

The custom hook returns a value that represents its state. This value is stored in a variable in the component that uses the custom hook.

The component uses the value returned from the custom hook to render its UI.

If the custom hook updates its internal state using setState, the component re-renders with the updated state.

The cycle continues as the custom hook and the component continue to interact and update each other.

In summary, the custom hook and the component using it interact with each other and the changes made by one affect the other. This interaction is facilitated by React's mechanism of re-rendering the components when their state or props change.

7)so now what if i have eventlistener on a button and when button is clicked the state is updated so now will component and custom hook are re-rendered?

Yes, if you have an event listener on a button that updates the state, the component and the custom hook will both be re-rendered. When the state is updated, React will trigger a re-render of the component that uses that state. If the state is being updated within a custom hook, then the hook will also be re-executed and its return value will be updated. This updated value will be used by the component, which will trigger another re-render. In this way, the component and the hook are both updated whenever the state is changed, and a re-render will occur.

8)each instance of the custom hook has its own private state that is managed by React, and React knows which state belongs to which component instance by keeping track of the component identity internally.

Day 10 >>>>>>

you should know about pros and cons of native css,scss ,styled components and css frameworks.

🔴SCSS (Sass) is a preprocessor for CSS that extends the functionality of CSS, making it easier and more efficient to write and maintain stylesheets. Here are some reasons why you might want to use SCSS in your projects:

Variables: SCSS allows you to use variables to store and reuse values such as colors, fonts, and sizes. This makes it easier to maintain and modify your stylesheets.

Nesting: SCSS allows you to nest selectors within each other, making it easier to organize your styles and avoid repetition.

Mixins: SCSS allows you to create reusable blocks of styles called mixins, which can be included in multiple selectors. This makes it easier to maintain consistency and avoid repetition.

Functions: SCSS allows you to write and use functions to perform calculations, create color schemes, and manipulate values.

Modularization: SCSS allows you to break up your stylesheets into smaller, more manageable files, which can be compiled into a single CSS file for production.

Improved readability: SCSS's syntax is similar to other programming languages, making it easier to read and understand for developers who are familiar with other programming languages.

🔴Styled Components is a popular library for styling React components. Here are some of the pros and cons of using this library:

Pros:

Scoped styles: Styled Components creates styles that are scoped to the component they are defined in, which reduces the risk of style conflicts in your application.

Code organization: Styles are defined in the same file as the component, which makes it easier to read and understand the code. This can also make it easier to maintain and update the code.

Dynamic styling: Styled Components allows you to use dynamic values such as props and theme variables to generate styles at runtime.

Server-side rendering: Styled Components can be used for server-side rendering, which can improve the performance and user experience of your application.

Flexibility: Styled Components can be used with any React-based library or framework, making it a versatile choice for styling React applications.

Cons:

Learning curve: There may be a learning curve when using Styled Components for the first time, especially if you are new to CSS-in-JS.

Performance: Styled Components may have a performance impact on your application, especially if you use complex or deeply nested styles.

Tooling: The tooling for Styled Components may be less mature than other CSS-in-JS solutions, which may limit your ability to use certain features or integrations.

Additional build step: Styled Components requires an additional build step to generate the styles, which may add complexity to your build process.

🔴CSS frameworks are pre-written, ready-to-use sets of CSS code that can be used to build web applications. Here are some of the pros and cons of using CSS frameworks:

Pros:

Faster development: CSS frameworks can speed up development by providing pre-written CSS code and components that can be used to build web applications quickly.

Consistency: CSS frameworks can help ensure consistency in design and style across an application. This can help make the application more visually appealing and easier to use.

Responsiveness: Many CSS frameworks are designed to be responsive, meaning that they automatically adjust to different screen sizes and devices.

Cross-browser compatibility: CSS frameworks are typically tested across multiple browsers, which can help ensure that your application looks and works the same in different browsers.

Community support: Many CSS frameworks have active communities of users and contributors, which can provide support and resources for developers.

Cons:

Learning curve: Using a CSS framework often requires learning a new set of tools and conventions, which can take time and effort.

Limitations: CSS frameworks can be limiting in terms of design and customization. Some developers may find it challenging to modify the pre-existing styles and components to fit their needs.

Overhead: CSS frameworks often have large codebases, which can increase the size of your application and slow down its performance.

Unnecessary features: CSS frameworks often include features that may not be needed in your application, which can lead to unnecessary code and overhead.

Debugging: Debugging can be more challenging when using a CSS framework, as the pre-written code can be difficult to understand and modify.

1)What is content,theme and plugins in configuration file(tailwind.config.js)
Content:
The content section of your tailwind.config.js file is where you configure the paths to all of your HTML templates, JavaScript components, and any other source files that contain Tailwind class names.

theme:
The theme property is where you can customize and extend the default styles provided by Tailwind. The extend property within theme is where you can add your own custom CSS classes, as well as modify existing classes. For example, you can use the extend property to add new color palettes, font families, or spacing scales to your Tailwind configuration. You can also use it to override any of the default styles provided by Tailwind.

plugins:
The plugins property is where you can add any third-party plugins that extend the functionality of Tailwind. These plugins can provide additional CSS classes or modify existing ones. For example, there are Tailwind plugins available that provide utility classes for working with grids, aspect ratios, and much more.

2)When you need to give exact width/height/dimensions you use square brackets.
for eg:-w-[20px] this gives width of 20 pixels

3)pros of tailwind
-standardised css
-easy debugging at go(in the same file)
-time saving
-NO repetion of class with same style

4)cons of tailwind
-It has learning curve
-It makes code looks little bit ugly

Day 11 >>>>>>
1)Props Drilling
Props drilling is a term used in React to describe the process of passing data through multiple components in order to get to a child component that needs the data. This happens when you have a deeply nested component that needs data from its parent component, but the data is not available to it directly.

To solve this problem, you have to pass the data down as props through all the intermediary components until it reaches the child component that needs it. This process is called props drilling.

🔴Cons of props drilling:-
1)Tracking the data:-When there is error and we debug teh code we have to track down from where the data is coming from
2)Rendering of unwanted components:-When a props is update in a component all components used to passed props are re-rendered now there may be component that are not using the props they just help for props drilling and hence they are also re-rendered which is not even required.

2)context.displayname is used to provide name to context so that it can be used to track in dev tools

Day 12>>>>>

In a Redux application, actions are dispatched to the store, and the corresponding reducer is called with the current state object and the action object as arguments. The reducer then returns a new state object that reflects the changes made by the action. This new state object becomes the current state of the Redux store, and any connected components are re-rendered with the new state.

In a typical Redux workflow, the process of updating the state happens as follows:

An action is dispatched to the Redux store.
The corresponding reducer is called with the current state object and the action object as arguments.
The reducer modifies the state object immutably and returns a new state object that reflects the changes made by the action.
The new state object becomes the current state of the Redux store, replacing the previous state.
Any connected components are re-rendered with the new state, and the UI updates to reflect the changes.
This process ensures that the state of the application is always consistent and predictable, and that any changes to the state are tracked and can be easily traced back to the actions that caused them.

1)Redux provides us a global that is accessible and modifiable throughout the whole application

2)In redux we store all the states in one global store called store and store them in different slices(sections)

3)In redux we don not update state directly we first dispatch an action which calls a reducer function that update the state

4)All updates in redux should be done immutably

5)the name field in the createSlice function is used to define the name of the slice in the Redux store, while the name of the reducer in store.js is used to specify the name of the slice in the store state object.
If the names don't match, the slice and its state will still exist in the store, but it may be harder to access or manipulate the data in the slice. For example, if you name the slice "counterSlice" in createSlice and then try to access the state using store.getState().counter, it won't work because the slice name is different.
So to avoid confusion and make it easier to access the state in the store, it's best practice to keep the slice name and reducer name the same.
In the code you provided, the name of the slice is "counter", and the name of the reducer is "counterReducer", which are slightly different but still related. This won't cause any issues as long as you use the correct name when accessing the state in the store.

6)Any time an action has been dispatched and the Redux store has been updated, useSelector will re-run our selector function. If the selector returns a different value than last time, useSelector will make sure our component re-renders with the new value.

7)useselector and usedipatch hook in redux
useSelector is a hook that allows you to extract data from the Redux store state. It takes a function as an argument that maps the store state to a value that you want to use in your component. Whenever the store state changes, useSelector will re-render your component with the new value. Here's an example of how to use useSelector:

import { useSelector } from 'react-redux';

function MyComponent() {
const counter = useSelector(state => state.counter);
return <div>{counter}</div>;
}

useDispatch is a hook that allows you to dispatch actions to the Redux store. It returns a reference to the dispatch function that you can use to dispatch actions from your component. Here's an example of how to use useDispatch:

import { useDispatch } from 'react-redux';

function MyComponent() {
const dispatch = useDispatch();
const handleClick = () => {
dispatch({ type: 'INCREMENT' });
};
return <button onClick={handleClick}>Increment</button>;
}

Day 13>>>>>
1)Test Driven Development
We write test cases even before writing our code.

2)different types of testing
-Manual Testing -: It requires a manual labor to test the app.
-automated testing -: It is some code used to test another code.
-end to end testing
-selenium testing
-headles browsers
-unit testing
-integration testing

3)Steps for testing
--We are installing and using react testing library and jest.
--Now we have to configure jest so we use npx jest --init
--we will specify whether we are using typescript,testing environment(jsdom for frontend),want to see coverage reports,provider used for coverage(we are using babel),
--Install jest-environment-jsdom cause it is not shipped by default after version 28
--create our first test file we will create **tests** in our components folder for a normal javascript file that contain JS code to return sum of two number
--when we import sum file(file that contains sum function) jest throws an error that cannot use import statement outside a module and hence we need to configure jest with babel we need babel-jest for that
--when we try to import header component for testing jest does not know jsx hence we need one more library @babel/preset-react and a configuration ["@babel/preset-react", {"runtime":"automatic"}]

{
"presets": [["@babel/preset-env", {"targets": {"node": "current"}}],["@babel/preset-react", {"runtime":"automatic"}]]
}

4)What is jsdom
jsdom is a JavaScript implementation of the Document Object Model (DOM) used by web browsers. It allows you to simulate a browser environment within a Node.js environment, which is useful for testing web applications using tools like Jest.
In the context of Jest, jsdom is used to provide a DOM implementation for tests to interact with. This allows you to write tests that interact with the DOM just like a real web application would. jsdom also provides other browser-related functionality such as the window and document objects, which are often used in web application development.
Jest uses jsdom by default when running tests, so you don't need to install or configure anything to use it. However, you can configure Jest to use a custom implementation of the DOM if you need to.
Keep in mind that jsdom only provides a partial implementation of the browser environment, and some browser APIs may not be available or may behave differently than they would in a real browser. It's important to be aware of these limitations when writing tests that interact with the DOM or other browser APIs.

5)When you run tests with Jest, it automatically compiles and executes your JavaScript code, but it does not handle other file types such as images by default. If your code includes images, you may need to create mock files for those images in order to test your code properly.

In the case of PNG images, you can create a mock file for the image by creating a new JavaScript file that exports the path to the image file. This allows Jest to correctly resolve the image path in your code, while using the mock file instead of the actual image file during testing.

Here's an example of how you can create a mock file for a PNG image:

// **mocks**/image.png.js
module.exports = '/path/to/mock/image.png';
Then, you can update the Jest configuration to use this mock file for PNG images. In your jest.config.js file, you can add the following configuration:

module.exports = {
// ...
moduleNameMapper: {
'\\.png$': '<rootDir>/**mocks**/image.png.js',
},
};
This configuration tells Jest to use the **mocks**/image.png.js file whenever it encounters a .png file in your code.
By creating a mock file for your image, you can test your code without relying on the actual image file. This can make your tests faster and more reliable, since they won't be affected by changes to the image file or the external environment.

6)Do not have provider error is thrown because we are rendering just header in header.test.js and hence we need to wrap it in provider and provide store to it

7)In order to use Router(creatBrowserRouter) in our test file we need StaticRouter that is imported from react-router-dom/server

8)We cannot use fetch in jest and hence we create dummy function for fetch using jest.fn() as per following

global.fetch=jest.fn(()=>{
Promise.resolve({
json: Promise.resolve(data)
})
})

9)To enable HMR for testing

'watch-test':'jest --watch'

10)Mock jest function in test file
In the context of a Jest test file, you may want to mock global.fetch in order to test code that uses it. This is typically done to avoid making actual network requests and to control the response of the function.

The code you provided is an example of how you can mock global.fetch to return fake data, instead of making a network request. Here's what each line of the code does:

global.fetch = jest.fn(() =>
Promise.resolve({
json: () => Promise.resolve(fakeData),
})
);
global.fetch = jest.fn(): This line sets global.fetch to a Jest mock function. This means that when any part of your code calls global.fetch, it will actually be calling this mock function instead of the real fetch function.

() => ...: This is an arrow function that is passed as an argument to jest.fn(). It is the implementation of the mock function.

Promise.resolve({json: () => Promise.resolve(fakeData)}): This line returns a Promise that resolves to an object with a json() method. The json() method is also a Promise that resolves to fakeData. In other words, this mock function returns a Promise that looks like the response object that fetch would normally return.

fakeData in this context is a variable that should contain the fake data that you want to use for your test.

By mocking global.fetch in this way, you can test your code that depends on the fetch function without making actual network requests, and with control over the data that is returned.

11)enzyme vs react testing library
Enzyme and React Testing Library are both popular testing libraries for React applications, but they differ in their approach to testing and the types of tests they are best suited for.

Enzyme is a testing utility library for React that provides a shallow and full rendering API, as well as utilities to manipulate and traverse the React component tree. Enzyme's API is designed to be intuitive and easy to use for developers familiar with jQuery. Enzyme is good for testing React components in isolation, and is especially useful for testing component behavior and props.

React Testing Library, on the other hand, is a lightweight testing library that is designed to encourage testing best practices. It focuses on testing the behavior of your components as they are used by real users, rather than testing implementation details. React Testing Library provides a set of utilities that make it easy to query and interact with the DOM, and encourages testing the rendered output of your components.

Both Enzyme and React Testing Library have their strengths and weaknesses, and the best choice depends on your specific testing needs and preferences. If you want to test component behavior in isolation, Enzyme may be a good choice. If you want to test your components from a user's perspective, React Testing Library may be a better fit.

12)what is jest and why do we use it
Jest is a JavaScript testing framework that is widely used in the React community for testing React applications. It provides a simple and powerful way to write tests, and comes with features like test runners, test suites, and assertions to make it easier for developers to write and run tests.

Jest is a popular choice for testing React applications because it was created by Facebook, the creators of React, and is designed specifically for testing React code. It also has a large community of users who contribute to its development and provide support to other users.

Some benefits of using Jest for testing include:

Easy setup and configuration
Built-in test runners and assertions
Supports both synchronous and asynchronous testing
Provides a wide range of mock functions to simplify testing
Can be integrated with other testing tools and frameworks, such as Enzyme and React Testing Library.
Overall, Jest provides a powerful and flexible tool for testing React applications, and is widely used by developers and organizations for testing their code.

Day 14>>>>>
Machine Coding interview

1)Managing Time is toughest to crack in a machine coding interview
-You can do practice to crack the time in interview(this is before interview thing)
-planning will help you to crack in interview in runtime

Steps for machine coding:-
➡️Requirements clarification
🔴Understand Features first
🔴Tech Stack:-Specify your interviewer what are you going to use for building app.for eg:- You can tell i am going to use react,tailwindcss,redux,react-router-dom,bundler,testing libarary,etc.
➡️UI Design
🔴Discuss What are you going to include in your app.
🔴Tell them about all your components and the pages you will direct to.

2)Path parameters vs Query parameters
Path parameters and query parameters are both used to pass data to a web application, but there are some differences between them.

Path parameters are part of the URL path and are used to identify a specific resource. They are typically used to retrieve data related to a specific identifier or object. In a React Router, path parameters are defined in the route using a colon followed by the parameter name. For example, in the route /users/:userId, userId is a path parameter.

Query parameters, on the other hand, are added to the end of the URL and are used to provide additional information about the resource being requested. They are typically used for sorting, filtering, or searching data. Query parameters are defined using the ? character in the URL followed by the parameter name and value, separated by =. Multiple query parameters can be separated by &. For example, in the URL /search?q=react&sort=asc, q and sort are query parameters.

In summary, path parameters are used to identify a specific resource, while query parameters are used to provide additional information about the resource being requested.

3)URLsearchparams
