24/12/22
Day 1 >>>>>
Q.read about emmet  
Emmet is a plugin for text editors that allows users to write and expand abbreviations and snippets of HTML, XML, and other structured code. It is designed to be a fast and efficient way to write and edit code, by allowing users to quickly expand short, predefined code snippets into longer blocks of code.

Q.what is cdn
A content delivery network (CDN) is a system of distributed servers that deliver web content to users based on their geographic location. CDNs are used to improve the performance and availability of websites, by reducing the distance that data has to travel and providing redundant servers to handle traffic spikes.

CDNs work by storing copies of a website's static content, such as images, JavaScript files, and CSS files, on servers located in strategic locations around the world. When a user accesses a website that uses a CDN, the CDN will serve the content from the server that is closest to the user's location. This helps to reduce the amount of time it takes for the content to load, improving the user experience.

CDNs also help to improve the availability of websites by providing redundant servers to handle traffic spikes. If one server becomes overloaded or goes down, the CDN will redirect traffic to other servers in the network, helping to ensure that the website remains available to users.

Overall, CDNs are an important tool for improving the performance and availability of websites, and are used by many large and popular websites to deliver content to users around the world.

Q.what is crossorigin?

Q.Does react append content to root with some existing data or overwrites everything?
react overwrites everything that is already present in root

Q.i have created two roots in my react page and rendered both of them but only on root is being rendered why?
In a React application, it is generally not recommended to have multiple root elements in a single page. This is because React expects a single root element to wrap all of the other elements in the component hierarchy. If you try to render multiple root elements in a single page, only the first root element will be rendered, and the rest will be ignored.

Q.Async VS Defer
They are attributes of script tag.
when a page fetched from server there are two things first html rendering and script file loading.
Normal script tag:-
In this when page is loaded the html rendering start and when a script file is encountered the rendering is stopped and file is fetched and executed and once it is done the rendering starts again.
Script tag with async attribute:-
In this when page is loaded the html rendering starts and when a script file is encountered the the file is fetched asynchronusly while rendering is going on and once the file is fetched rendering stops and file is executed and after that rendering starts again.
Script tag with defer attribute:-
In this when page is loaded the html rendering starts and all script files  encountered are fetched asynchronusly while rendering is going on and once the rendering is done  all fetched files are executed one by one.
https://www.youtube.com/watch?v=IrHmpdORLu8

Emmet:

https://blog.logrocket.com/type-html-faster-react-emmet-vs-code/

https://dev.to/raaynaldo/speed-up-code-your-html-using-emmet-in-vscode-nesting-operators-201o

Library VS Framework:

https://www.freecodecamp.org/news/the-difference-between-a-framework-and-a-library-bd133054023f/

CDN:

https://www.imperva.com/learn/performance/what-is-cdn-how-it-works/

React VS React DOM:

https://www.geeksforgeeks.org/how-react-and-reactdom-works/

Cross-Origin:

https://www.dofactory.com/html/script/crossorigin

https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/crossorigin

Development VS Production build:

https://react-cn.github.io/react/downloads.html




Day 2 >>>>>

1.Bundlers:-
A bundler is a development tool that combines many JavaScript code files into a single one that is production-ready loadable in the browser. A fantastic feature of a bundler is that it generates a dependency graph as it traverses your first code files.
This implies that beginning with the entry point you specified, the module bundler keeps track of both your source files’ dependencies and third-party dependencies. This dependency graph guarantees that all source and associated code files are kept up to date and error-free.
VIDEO REFERENCE :- https://youtu.be/3UWlufSzO4k

2.Module:-
A module is a Javascript file.
However unlike a normal Javascript file, a module can specify which variables and functions can be accessed outside the module. Other sections of the module cannot be accessed. A module can also load other modules.

3.Packages:-In JavaScript, a package is a collection of code, resources, and metadata that is stored in a directory on your computer and is described in a package.json file

4.Dependencies:-They are all the packages that we need in the project

5.caret vs tilde:-
The three numbers in a version number represent the major version, minor version, and patch level. They represent the level of change in the software and the level of compatibility with previous versions.
The first number (the major version) represents a major release of the software that contains significant new features or changes. When the major version number changes, it means that the software has undergone significant changes that might break compatibility with previous versions.
The second number (the minor version) represents a minor release of the software that contains new features or changes that are backward-compatible with previous versions. When the minor version number changes, it means that the software has undergone changes that add new functionality but do not break compatibility with previous versions.
The third number (the patch level) represents a patch release of the software that contains bug fixes and other small changes. When the patch level number changes, it means that the software has undergone changes that fix bugs or improve performance but do not add new features or break compatibility with previous versions.
For example, if a software has version number of "1.2.3" it means that it is major version 1, minor version 2 and patch level 3 of the software.

The caret (^) is used in a package version number to indicate that the package should be updated to the latest version that is compatible with the current version. For example, if a package has a version number of "^1.2.3", it means that it should be updated to the latest version that is compatible with version 1.2.3. This would include any version that starts with "1.2", such as "1.2.4" or "1.2.5", but would exclude "2.0.0" or higher.

The tilde (~) is used in a package version number to indicate that the package should be updated to the latest version that is compatible with the current version, but only within the same minor version number. For example, if a package has a version number of "~1.2.3", it means that it should be updated to the latest version that is compatible with version 1.2.3, but only within the same minor version number. This would include any version that starts with "1.2", such as "1.2.4" or "1.2.5", but would exclude "1.3.0" or higher.

6.Package vs Package-lock-json:-package-lock-json locks and tells you exact version you are using in your system.
There is no need to put your package-lock-json file in gitignore.It maintains the integrity because it has hash which ensure that version on local and server are same(when you compare them).
Reference:-https://medium.com/hackernoon/do-i-really-need-package-lock-json-file-321ce29e7d2c#:~:text=If%20you're%20collaborating%20on,where%20npm%20modifies%20either%20package.

7.hash(sha512)
SHA-512, or Secure Hash Algorithm 512, is a hashing algorithm used to convert text of any length into a fixed-size string. Each output produces a SHA-512 length of 512 bits (64 bytes).
This algorithm is commonly used for email addresses hashing, password hashing, and digital record verification. SHA-512 is also used in blockchain technology, with the most notable example being the BitShares network.

8.Node module:-It contains all the modules of packages(reusable code)

9.npx:-It means execute using parcel.

10.type="module":-
A script tag having type="module" attribute specifies that it to be considered as a Javascript module. It may be importing other Javascript module(s) inside it and becomes a "top-level" module for the imported modules.
When a script file has the type="module" attribute, the browser treats it as a module and parses and executes the script in a specific way. The browser will create a new scope for the module, so that variables, functions, and classes defined within the module are private, and can only be accessed from within the module.

11.Hot module replacement:-
It refers that parcel keeps track of all updation.
It uses File Watchers algorithm(This algorithm is built in c++).
Whenever you update something in your code there is no need for you to manually to refresh the page parcel will automatically update it for you.Generally it updates Independent as well as Dependent modules in your project.
It update the changed modules and then track the module that are affected by the module changed and changes their value as well it does not update whole code every time.
for eg:-There are 4 module A,B,C,D and now B is changed then it will update the B and reflect it,it will not change A,C,D.
Now if C use data from B which changes then C will also be changed

12.dist:-
dist is a faster development build of our project which is hosted on server(local) by parcel.
It is minified version of our huge project like we used npm build in webpack(harry tutorials).

13.Parcel advantages:-
1) bundling our code
2)minifying the code
3)removing all the console log(cleaning the code)
4)it does image optimization(compress them)
5)it provides caching while development->The time required to build development build first is largest and subsequently the time required decreases
6)It compresses your files(decreases the size of your js,html,css files). for eg:-it changes names of your variables (with large names )in js to some small names like alphabets/something.
7)It also handles compatability with older versions.
8)It enables https on development build.
9)It manages your port number.
10)It uses consistent hashing algorithm.
11)It has zero configuration.

14.We should put parcel.cache in gitignore because anything that can be auto generated will be put in gitignore.

15.Transitive dependencies:-
A transitive dependency is a library or module that is depended on by another library or module, even though the main application code does not directly depend on it. 
For example, suppose that a React application depends on library A, which in turn depends on library B. In this case, library B is a transitive dependency of the React application, because the application code does not directly depend on it, but it is required for library A to work correctly.

16.BrowserList:-It is a package used to make your web app compatible for older versions of browser.
It is automatically added by parcel when we are using it.
Browserslist is a tool that allows specifying which browsers should be supported in your frontend app by specifying "queries" in a config file. It's used by frameworks/libraries such as React, Angular and Vue, but it's not limited to them.
Reference:-https://browsersl.ist/

17.package.json scripts:-
scripts are terminal commands that perform a set of actions. 
To execute your Script, use the ‘npm run <NAME-OF-YOUR-SCRIPT>’ 


What we done today:-
We installed parcel (a bundler) as a dev dependency in our project first.
We installed react package in our project......we are not using cdn any more.
We installed react-dom package in our project......we are not using cdn any more.

Day 3 >>>>>>
1)Babel-plugin-transform-remove-console:- It is used to remove the console logs from your projects.

2)What are plugins

3)what is .babelrc?
It is a configuration file for babel 

4)React Key Concilation:-Key should be given to children elements of similar types.
When elements are rendered in a list, React uses the key attribute to keep track of which elements are added, removed, or re-ordered. Without a key, React doesn't have a way to keep track of the elements in the list, so it has to re-render the entire list whenever a change is made.

When React renders a list of elements, it creates a virtual representation of the elements in memory, called the virtual DOM. The virtual DOM is a lightweight representation of the real DOM, and it is used to keep track of the elements that are rendered in the list.

When a change is made to the list, such as an element being added, removed, or re-ordered, React has to update the real DOM to match the virtual DOM. In order to do this, React uses a process called "reconciliation". During reconciliation, React compares the virtual DOM with the real DOM, and it determines which elements have changed and need to be updated.

5)Virtual Dom and Real dom in react
In React, the virtual DOM (VDOM) is a lightweight representation of the real DOM (Document Object Model). The real DOM is the actual structure of the web page, and it is used by the browser to display the content of the page. The virtual DOM, on the other hand, is a representation of the real DOM that is kept in memory, and it is used by React to efficiently update the real DOM.

The virtual DOM is a tree-like structure, where each node represents an element in the real DOM. When a change is made to the virtual DOM, such as an element being added or removed, React uses a process called "reconciliation" to determine how the real DOM should be updated.
The use of virtual DOM allows React to minimize the number of changes made to the real DOM, thus making the updates faster and more efficient. This is important because updating the real DOM can be slow and resource-intensive, especially when working with large or complex web pages.

It's worth noting that React's virtual DOM does not physically exist on the page, it only exists in memory and is used to optimize the update process. It's a mechanism that React uses to optimize the update process, making it faster and more efficient

6)JSX
JSX is not html in javascript..it is a html like syntax in javascript
Superpowers of jsx:-
readability,maintainability and protects from cross side scripting
JSX itself does not directly prevent cross-site scripting (XSS) attacks. However, when used in conjunction with other security measures, it can help to make it more difficult for an attacker to exploit XSS vulnerabilities in a web application.

When you use JSX to build a React application, React automatically escapes any user input that is included in JSX elements. This means that any special characters that could be used to inject malicious code (such as <, >, and &) are converted to their corresponding HTML entities, so that they are not treated as code.
For example, if an attacker tries to include a script in a user's input like this:

<script>alert("XSS Attack!")</script>

React will automatically escape the special characters, so that it is rendered as plain text on the page, not as a script that can be executed by the browser:

&lt;script&gt;alert("XSS Attack!")&lt;/script&gt;

7)What is difference between html and jsx

8)what is babel and how it is used for transpiling jsx or es6 code?
Whenever you run build or start command in parcel first of all babel is used to transpile(convert jsx to normal javascript,convert to compatible with previous versions of browsers) the whole javascript code
Babel takes jsx and internally uses react.createElement to convert into object(object created by react.createElement) and then transform it into dom
BABEL=>JSX=>react.createElement=>OBJECT=>DOM

REACT CODE:-
const Header=()=>{
    return (
        <h1>hello world! through functional component</h1>
    )
}
const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<Header/>);

CODE TRANSPILED BY BABEL:-
const Header = () => {
  return React.createElement("h1", null, "hello world! through functional component");
};

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(React.createElement(Header, null));



When you use Parcel to build a React application, it automatically includes and configures Babel to transpile JSX code into JavaScript that can be understood by web browsers.

Parcel is a web application bundler that can handle many types of files, including JavaScript, CSS, and HTML. One of its features is the ability to automatically detect and handle the dependencies of your application, including transpiling JSX code with Babel.

When you start a development server with parcel, it will look for any .js, .jsx files in your application and it will automatically transpile them using Babel. It will also look for any configuration files like .babelrc or package.json, if it finds any of these configuration files it will use them.

So you don't have to explicitly include Babel as a dependency in your project or configure it to transpile JSX code. Parcel will handle it automatically for you.

When you build your application with parcel, it will look for any JSX elements in your code, it will transpile them using Babel to JavaScript, and bundle them with the rest of your application. So the final output will be a single JavaScript file that contains all the code in your application, including the transpiled JSX code, that can be understood by web browsers.

In summary, when you use Parcel to build a React application, it automatically includes and configures Babel to transpile JSX code into JavaScript that can be understood by web browsers. You don't have to explicitly include Babel as a dependency or configure it, Parcel will handle it automatically for you. It will look for any JSX elements in your code, transpile them using Babel and bundle them with

9)Component=>
Component is a JavaScript class or function that represents a reusable piece of UI. 
Functional components: These are JavaScript functions that accept props as an argument and return a JSX element. They don't have their own state and lifecycle methods.
Class components: These are JavaScript classes that extend the React.Component class. They have their own state and lifecycle methods. They also accept props as an argument and return a JSX element, but the way that it is done is different from functional components.
Functional component
Functional component is normal function that returns a jsx.
Name of a component starts with a capital letter.

10)Component Composition
Component composition is a technique in React where you can build a complex component by combining smaller, simpler components. The smaller components are called "composable components" or "sub-components" and the complex component is called the "composite component."
For eg:-
function WelcomeDialog() {
  return (
    <div>
      <h1>Welcome</h1>
      <p>Thank you for visiting our site.</p>
      <Button label="Close" onClick={() => console.log("closing dialog")} />
    </div>
  );
}

function Button({ label, onClick }) {
  return <button onClick={onClick}>{label}</button>;
}

In this example, the WelcomeDialog component is the composite component, and the Button component is the sub-component. The WelcomeDialog component renders the Button component inside its JSX.

11)Type Attribue
The type attribute is used to specify the type of script is being used

Day 4 >>>>>>
1)Any jsx expression include only one root parent within which all children elements are included and further child elements can be included in those children elements.

2)React.Fragment
Any jsx expression must have single root parent.So you create a div with no classess/id and then add include all children elements into it.But this forces you to add unnecessary extra div in your code.
for eg:-
const header=()=>{
  <div>
    <Logo/>
    <NavItems/>
  </div>
}
Now React.Fragment is component that is exported by React and you can use it instead of a extra div as shown below.
const header=()=>{
  <React.Fragment>
    <Logo/>
    <NavItems/>
  </React.Fragment>
}
This short hand syntax for <React.Fragment></React.Fragment> is <></>

3)Can we use React.Fragment in React.Fragment?
Yes of course!

4)join array items?
You can join array items in JavaScript using the join method. This method concatenates all elements of an array into a single string, separated by a specified separator.
for eg:-
let arr = [1, 2, 3, 4];
let str = arr.join(', ');
console.log(str); // Output: "1, 2, 3, 4"


5)Config driven ui?
In this UI changes according to the data provided which it means it is driven by configuration provided by backend.
for eg:- swiggy don't have add carousels for customer in maharashtra then it will get data from backend which provides config about not to show carousel ads while other location it may show the carousel ads.

6)optional chaining?
The optional chaining (?.) operator accesses an object's property or calls a function. If the object accessed or function called is undefined or null, it returns undefined instead of throwing an error.
The ?. operator is like the . chaining operator, except that instead of causing an error if a reference is nullish (null or undefined), the expression short-circuits with a return value of undefined. When used with function calls, it returns undefined if the given function does not exist.

For eg:-
const nestedProp = obj.first?.second;

By using the ?. operator instead of just ., JavaScript knows to implicitly check to be sure obj.first is not null or undefined before attempting to access obj.first.second. If obj.first is null or undefined, the expression automatically short-circuits, returning undefined.

7)What is cloudinary id?

8)Spread operator?

9)diffing algorithm,react fiber?
diffing algorithm is an algorithm used by react in order to differ the old virtual dom and new virtual dom and find the changes/updates that are made and to be reflected in the real dom.
It is based no two assumptions:-
1)If the root elements are different then it will create completely different tree hence previous dom is unmounted completely and new virtual dom is rendered.
2)If root elements are same then it compares attributes then it compares childrens recursively.If a parent element has multiple same elements in it then key is used to compare them.

10)why not to use index as a key in react?
In React, keys help identify which items have changed, are added, or are removed. Using the index of an item as a key value is discouraged because it can lead to unexpected behavior when items are reordered or added/removed.
Imagine you have a list of items that you are rendering using map function, with each item being assigned a unique key. If the items in the list change frequently (e.g. being added, removed, or reordered), the index of each item will also change. When this happens, React will re-render the entire list and treat the new list as a completely different set of elements from the previous list, even if some of the items are the same. This can cause performance problems because React will need to re-render the entire list each time there is a change, instead of just updating the specific elements that have changed.

Day 5 >>>>>>
1)What are imports and exports
Imports and exports are JavaScript language features that allow you to include code from one module in another module. The "import" statement is used to include exports from another module in your code, while the "export" statement is used to make values or functions available for other modules to use. Imports and exports allow you to modularize your code and share functionality between different parts of your application.

2)Input tag not working??
A component in React is updated when its state or props change. React will re-render the component whenever a change is detected, which ensures that the component's output is updated with the latest data.
When you create a input tag in react and try to enter input in it you are not able to do it because
If you have not defined a onChange event handler for an input in React, it may not work because the input's value will not change when the user types in it. This is because React's state management system relies on the onChange event to detect changes in the value of an input element and update the state accordingly. Without the onChange event handler, the input's value will remain unchanged, and the user will not be able to enter any text. To fix this issue, you should add an onChange event handler to the input element and use it to update the state with the new value.

3)What is state?
In React, state refers to the data or variables that determine a component's behavior and render information to the user. It is considered as an internal data structure of a React component and is only accessible within the component.

4)what is react hooks?
React hooks are nothing but just a bunch of javascript functions.
In React, hooks are a way to add state and other React features to functional components. They allow developers to use state and other React features without writing a class component.
Hooks starts with use keyword.

5)Usestate Hook
Usestate hook is used to create local state variables in react.
Usestate returns an array which includes two value first one is variable that stores value and second one is the function used to set(change) the value of function.
Syntax:-
const [state, setState] = useState(initialState);
state is name of variable in which value is stored.
setState is a function which is used to update the state.The setState function in React updates the component's state and triggers a re-render of the component. When the component's state is updated, React performs a shallow comparison between the current state and the next state to determine if a re-render is necessary. If the comparison determines that the component's render method should be re-executed, the component is re-rendered, and the updated state is reflected in the component's UI.

Day 6 >>>>>>
1)What are microservices?
Microservices is an architectural style that structures an application as a collection of small, independent services that communicate with each other through APIs. Each microservice is focused on a specific business capability and can be developed, deployed, and scaled independently of the other services in the application. This approach enables faster development, easier maintenance, and greater scalability compared to a monolithic architecture where everything is tightly coupled and deployed as a single unit.
 
for eg:- 
There is different team and project for UI,BackEnd,Logs,Notification,etc.

2)What is useeffect?
useEffect is a Hook in React that lets you synchronize a component with an external system. It can be used to fetch data from an API, handle user events, update the document title, and many other things.

The useEffect function takes two arguments:

A)A callback function that performs the side effect.
B)An optional dependencies array, which lets you control when the effect should fire.

Useeffect callback function is called after the render.

We useeffect(componentDidMount in class based component) for api call because first we render with shimmer or dummy ui until we fetch data and once we fetch data then we update state and render the real data.

3)What is shimmering effect?
Shimmer effects are loading indicators used when fetching data from a data source that can either be local or remote. It paints a view that may be similar to the actual data to be rendered on the screen when the data is available.

4)What is conditional rendering?
Conditional rendering in React refers to the practice of rendering different components or elements in the UI based on certain conditions. For example, you may want to display a specific component to a user based on whether they are logged in or not. 

5)In react javascript expressions can executed in curly braces but javascript statements cannot be executed why?
In JavaScript, expressions are pieces of code that return a value. They can be as simple as a single value like 5, or as complex as a function call, like Math.max(5, 10).

On the other hand, statements are complete units of execution. They don't return a value, but instead carry out some action, such as declaring a variable let x = 5, or defining a loop for (let i = 0; i < 10; i++).

In React, the curly braces are used to embed expressions, which return a value, in JSX code. On the other hand, JavaScript statements do not return a value, they execute actions. So, including a JavaScript statement inside the curly braces would not make sense, as it would not have any value to be embedded in the JSX. That's why JavaScript statements cannot be executed within curly braces in React.

6)What is monolith architecture?
Monolithic architecture is a software design pattern where the entire application is built as a single, independent unit. In a monolithic architecture, all the components of the system, such as the user interface, business logic, and database access, are tightly integrated into a single process or application. The entire application runs on a single server and communicates through a single database. Changes to the system often require a complete rebuild and redeployment of the entire application.
For example, consider a website for an e-commerce business that includes a shopping cart, payment gateway, product catalog, and order management system. In a monolithic architecture, all these components would be tightly integrated and deployed as a single, monolithic application.

7)What is async and await?
Async and Await are two keywords in JavaScript that are used to handle asynchronous operations in a more synchronous manner. The async keyword is used to declare an asynchronous function. The await keyword is used inside an asynchronous function to wait for the resolution of a Promise and to get the resolved value. With await, the code inside the function is blocked until the awaited Promise is resolved, making it look like a synchronous operation. This helps to simplify the handling of asynchronous operations and eliminates the need for callback functions and chaining Promises.

Day 7 >>>>>>
1)Never create a component inside an component

2)Never create Local state variable(state/usestate) in if-else condition or loops because this will create a incosistency that causes confusion for react.You should not create state variables in if-else statements or in loops in React because they may not be updated properly or may cause unexpected behavior. When a state variable is updated inside an if-else statement or a loop, it may not trigger a re-render of the component and cause unexpected behavior. Additionally, state variables should only be updated using the setState method to ensure that the component is re-rendered whenever the state changes. When you create a state variable inside an if-else statement or a loop, it becomes a local variable, which is not associated with the state of the component and will not trigger a re-render when it changes.

3)createBrowserRouter is the function that an array of objects as argument in which each object includes path and component related to it.Basically it is used to create router.
for eg:-
const appRouter=createBrowserRouter([
  {
    path:'/',
    element:<Applayout/>
  },
  {
    path:'/about',
    element:<About/>
  }
])

4)RouterProvider
In order to provide router to your router we use RouterProvider in render in which we pass a prop router={appRouter}
for eg:-
root.render(<RouterProvider router={appRouter}>)

5)errorElement
It is used to show the component that you want to display if invalid url/path is entered.
for eg:-
const appRouter=createBrowserRouter([
  {
    path:'/',
    element:<Applayout/>
    errorElement:<Error/>
  },
  {
    path:'/about',
    element:<About/>
  }
])

6)useRouteError
It is hook that returns a object that includes the information about error related to route.

7)Single Page Application
An SPA (Single-page application) is a web app implementation that loads only a single web document, and then updates the body content of that single document via JavaScript APIs such as XMLHttpRequest and Fetch when different content is to be shown.
A single-page application (SPA) is a web application or website that interacts with the user by dynamically rewriting the current page rather than loading entire new pages from a server. In an SPA, a single HTML page is dynamically updated as the user interacts with the application, giving the feeling of a smooth and fast user experience.

8)Two types of routing
server side routing
client side routing

9)Link component
Link component is used to link to routes.It does not reload the whole pages.

10)Nested Routing
If you want to load/show <About/> component when going to '/about' route but you want your header and footer there so you want replace <Body/> with <About/> for '/about' route this is called Nested Routing.

Outlet:-
<Outlet/> is a component which includes all the childrens according to route.

foreg:-
const Applayout=()=>{
    return (
        <>  
        <Header/>
        <Outlet/>
        <Footer/>
        </>
    );
}

const appRouter=createBrowserRouter([
    {
        path:'/',
        element:<Applayout/>,
        errorElement:<Error/>,
        children:[
            {
                path:'/',
                element:<Body/>
            },
            {
                path:'/about',
                element:<About/>
            }
        ]
    }
   
])

11)useParams
It is a hook provided by react-router-dom which gives parameters in the current url/path.

12)Object.values
In JavaScript, Object.values is a method that returns an array of the values of all enumerable properties of an object. It takes an object as an argument and returns an array of its values. For example:
For eg:-
let obj = { a: 1, b: 2, c: 3 };
let values = Object.values(obj);
console.log(values); // [1, 2, 3]

13)What happens when you console.log(useState())?
It logs a function in the console which shows that useState() is nothing but a javascript function at the end.

14)Nested Routing More deeply
Suppose you want to show profile in about on path /about/profile you can do as following
const Applayout=()=>{
    return (
        <>  
        <Header/>
        <Outlet/>
        <Footer/>
        </>
    );
}

const appRouter=createBrowserRouter([
    {
        path:'/',
        element:<Applayout/>,
        errorElement:<Error/>,
        children:[
            {
                path:'/',
                element:<Body/>
            },
            {
                path:'/about',
                element:<About/>,
                children:[
                  {
                    //do not do '/profile' cause server will assume path localhost:1234/profile and only profile means you want to
                    //append it to existing path/route i,e, to  localhost:1234/about/profile
                    path:'profile'
                    element:<Profile/>
                  }
                ]
            },
            {
                path:'/restaurant/:id',
                element:<RestaurantDetails/>
            }
        ]
    }
   
])

Day 8 >>>>>>
1)We cannot create class based component without extending a class by React.Component and using render method

2)render method is a method in the class based component that return some JSX.When a class-based component is called in the code, an instance of the component is created and rendered. The component's render method is then used to generate the JSX that represents the component's UI.

3)Constructor
It is a method in class based component/class that is called first.
every class based component has constructor which takes props as argument and state are declared and intialised in the constructor.
constructor(props)
{
  super(props)
  this.state={
    state1=value,
    state2=value
  };
}

4)Props in class based components
To access props in class-based components, you can use the "this.props" object. Props are passed to the component as arguments to the constructor and can be accessed using the "this" keyword inside the component.

5)state and updating states in class based components
To use state in class-based components, you need to initialize the state in the constructor of the component.To update the state, you can use the setState method, which takes an object that represents the updated state. You should never modify the state directly using assignment (e.g. this.state.count = 1).
for eg:-
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0,
    };
    this.incrementCount = this.incrementCount.bind(this);
  }
  incrementCount() {
    this.setState({
      count: this.state.count + 1,
    });
  }
  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.incrementCount}>Increment</button>
      </div>
    );
  }
}


6)Lifecycle in React
In REACT class based components constructor is called first(in beginning) then render method is called

7)componentDidMount
componentDidMount is a lifecycle method in React class-based components. It is called after a component is initially rendered to the DOM.

8)React lifecycle
React Lifecycle is divided into two phases 
I)Render Phase:-
In this phase constructor and render method is called
II)Commit Phase:-
In this phase React first actually update the real DOM and then run componentDidMount() method.

So now if there are more than one children let's say there are two childrens then first constructor and render of parent will be called later on constructor and render of first child is called and then constructor and render of second child is called and then componentDidMount of first child and then second child and then of parent is called.
now this happens because react patches up render phase of multiple childrens and then later on start commit phase for each children .....Now React does this because if it allows for first children to execute componentDidMount and there is api call in it that changes state then it will again goes to rendering phase and committing phase because of which other childrens are delayed/takes more time hence for optimization react does this.

For More Understanding:-https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/

9)Research Question:-
I)Why can i make componentDidMount async but i cannot make callback function in useeffect async
componentDidMount is a lifecycle method of class components. It's called after the component has mounted and the initial render is complete. This means that the component's DOM nodes have been created and added to the page, and the component's initial state and props have been set. componentDidMount is a good place to perform side effects like making an API call or setting up an event listener.

useEffect, on the other hand, is a hook that allows you to synchronize a component with an external system. For example, you can use useEffect to start a timer or to make an API call and update the component's state based on the response. Unlike componentDidMount, useEffect runs after every render, which includes the initial render. This means that if you want to run a side effect only once, you need to specify this by providing an empty array as the second argument to useEffect.

The reason that useEffect and its cleanup function must return a synchronous function or null, while componentDidMount can return a promise or any value, is because of how React manages and coordinates the effects. When using useEffect, you need to specify when the effect should re-run by providing its dependencies in the second argument. React will re-run the effect whenever any of the dependencies change.

The return value of useEffect is used to clean up any ongoing work before the effect is re-run. For example, you might use the cleanup function to stop a timer or to remove an event listener. Since the cleanup function is used to synchronize with the external system, it must be a synchronous function or null to ensure that React has full control over when and how it is executed.

If you use async in the useEffect or its cleanup function, it could cause unpredictable behavior, as React will not have full control over the timing and sequence of the cleanup and effect functions. In such cases, the cleanup function might not be executed in a timely manner or might not be executed at all, leading to unexpected behavior or memory leaks.

In conclusion, componentDidMount and useEffect are two different tools for performing side effects in React. componentDidMount is a one-time setup method for class components, while useEffect is a hook that allows you to synchronize a component with an external system and run an effect after every render. It's important to understand the difference between these two tools and how to use them properly to ensure that your components behave as expected.

II)Why do we have to write counstructor and super(props) in class based component
The constructor and super(props) are used in class-based components to set up the initial state and to call the constructor of the parent class.

The constructor is a special method that is called when an object is created from a class. In React, the constructor is used to set up the initial state of the component, to bind event handlers to the instance of the component, or to perform any other setup that is required when a component is first created.

super(props) is used to call the constructor of the parent class. In React, the parent class is React.Component. By calling super(props), you are giving the parent class the opportunity to set up its own state or perform any other initialization that is required before the component is fully created.

It's important to note that the constructor and super(props) are not necessary in every class-based component. In many cases, you can use state initializations and component lifecycle methods without using the constructor and super(props). However, if you need to do more complex setup when the component is created, then the constructor and super(props) are important to include


10)What happens if we are making an api call in componentDidMount of a child component?
In this case first parent's constructor and render method is runned then child's constructor and render method is runned now componentDidMount has an api call and we declared it as async(async componentDidMount) so it will take some time to load and hence parent's componentDidMount method is runned and then componentDidMount of child is runned.

11)Never ever compare react lifecycle with functional components.

12)i have setinterval function with time of 1 second in useeffect with dependency array having no state or props in it in my about componenent but when i navigate to another component and comeback to about component my time for setinterval subsequently increase why?

When you navigate away from a component, React unmounts the component and its state is lost. When you navigate back to the component, a new instance of the component is created and the component is re-mounted.

In this case, since you have a setInterval function running in a useEffect hook, each time you navigate to the component, a new interval is created and starts counting from 1 second. When you navigate away from the component, the previous interval continues running and doesn't stop, even though the component is no longer visible.

When you navigate back to the component, a new interval is created and starts counting from 1 second, so the time displayed in the component will be the sum of the time elapsed in all the previous intervals plus the time elapsed in the current interval.

To fix this issue, you can add a cleanup function to the useEffect hook that stops the previous interval when the component is unmounted. You can do this by returning a function from the useEffect hook that calls clearInterval with the ID of the interval. 

13)When will clean up function of useEffect will be called if i have state/props in its dependency array?
Yes, you can add a cleanup function to an useEffect hook that has dependencies. In this case, the cleanup function will be called every time before the effect runs, including the first time when the component is mounted. This can be useful if you need to perform some cleanup actions before the effect re-runs.